# -*- coding: utf-8 -*-
"""smoke_colour_detect.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KJ5FEDEzaKGzUeS57lZ_VZl70lYlbec_
"""

from google.colab import drive
drive.mount('/content/gdrive')

img_path = "/content/gdrive/MyDrive/ppe/images/smokecolour2.jpg"

import cv2
import numpy as np

def detect_smoke(image, xmin, ymin, xmax, ymax):
  """
  Detects smoke in a given image region.

  Args:
      image: The input image (numpy array).
      xmin, ymin, xmax, ymax: Region of interest coordinates.

  Returns:
      A masked image with smoke regions highlighted.
  """
  # Crop the image to the specified region
  roi = image[ymin:ymax, xmin:xmax]
  mask_color = (0, 0, 0)
  # Convert to HSV color space for better smoke detection
  hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)

  # Define thresholds for smoke color range in HSV
  lower_smoke = np.array([0, 30, 40])  # Adjust these values based on smoke color
  upper_smoke = np.array([60, 255, 255])

  # Create a mask for smoke pixels
  smoke_mask = cv2.inRange(hsv, lower_smoke, upper_smoke)

  # Apply morphological operations (optional)
  kernel = np.ones((5, 5), np.uint8)
  smoke_mask = cv2.morphologyEx(smoke_mask, cv2.MORPH_OPEN, kernel)
  smoke_mask = cv2.morphologyEx(smoke_mask, cv2.MORPH_CLOSE, kernel)
  contours, _ = cv2.findContours(smoke_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

  # Assuming there's only one significant smoke region (adjust if needed)
  if len(contours) > 0:
      smoke_contour = contours[0]

      # Approximate the contour with a polygon (optional)
      approx = cv2.approxPolyDP(smoke_contour, 0.01 * cv2.arcLength(smoke_contour, True), True)
      # Create a mask with the same size as the original ROI filled with black (0)
      contour_mask = np.zeros_like(roi, dtype=np.uint8)

      # Fill the contour mask with white (255) within the smoke contour
      cv2.fillConvexPoly(contour_mask, smoke_contour, color=255)

      # Draw the contour (polygon) on the masked ROI
      cv2.drawContours(roi, [approx], 0, mask_color, 2)  # Green contour with thickness 2
      # Fill the contour mask with the chosen color within the smoke contour


  else:
      print("No significant smoke contours found")

  # Invert the mask for better visualization (optional)
  smoke_mask = 255 - smoke_mask
 # Create a transparent mask with the chosen boundary color
  mask_vis = np.zeros_like(roi, dtype=np.uint8)
  mask_vis[..., 0] = mask_color[0]  # Set blue channel to mask color
  mask_vis[..., 1] = mask_color[1]  # Set green channel to mask color
  mask_vis[..., 2] = mask_color[2]  # Set red channel to mask color
  # Set alpha channel (transparency) based on smoke_mask (higher smoke probability = higher transparency)
  mask_vis[:, :, 2] = cv2.bitwise_not(smoke_mask) * 255

  # Blend the mask with the ROI using weighted average
  alpha = 0.1  # Adjust alpha for transparency (0 - fully transparent, 1 - fully opaque)
  masked_roi = cv2.addWeighted(roi, 1 - alpha, mask_vis, alpha, 0)


  # Overlay the masked ROI on the original image
  image[ymin:ymax, xmin:xmax] = masked_roi

  return image

# Example usage
image = cv2.imread("/content/gdrive/MyDrive/ppe/images/smoke_colour4.jpeg")
print(image.shape)

from google.colab.patches import cv2_imshow
xmin, ymin, xmax, ymax = (62,    42 ,     331 ,  120)  # Replace with your coordinates

masked_image = detect_smoke(image.copy(), xmin, ymin, xmax, ymax)

cv2_imshow(image)
cv2_imshow(masked_image)
cv2.waitKey(0)
cv2.destroyAllWindows()

# Crop the image to the specified region
roi = image[ymin:ymax, xmin:xmax]
mask_color = (0, 0, 0)
  # Convert to HSV color space for better smoke detection
hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)

  # Define thresholds for smoke color range in HSV
lower_smoke = np.array([0, 30, 40])  # Adjust these values based on smoke color
upper_smoke = np.array([60, 255, 255])

  # Create a mask for smoke pixels
smoke_mask = cv2.inRange(hsv, lower_smoke, upper_smoke)

def get_dominant_smoke_color(image, smoke_mask):
  """
  Calculates the average color within the smoke mask region.

  Args:
      image: The original image (numpy array).
      smoke_mask: The binary mask for smoke pixels (numpy array).

  Returns:
      A tuple representing the average BGR color of smoke.
  """
  # Extract channels from the image
  b, g, r = cv2.split(image)
  b = b[ymin:ymax, xmin:xmax]  # Extract relevant portion of blue channel
  g = g[ymin:ymax, xmin:xmax]  # Extract relevant portion of green channel
  r = r[ymin:ymax, xmin:xmax]  # Extract relevant portion of red channel

  # Count non-zero mask pixels (assuming smoke pixels are white)
  total_smoke_pixels = cv2.countNonZero(smoke_mask)

  # If no smoke pixels detected, return black
  if total_smoke_pixels == 0:
      return (0, 0, 0)

  # Calculate average color within smoke mask
  average_b = cv2.sumElems(b * smoke_mask)[0] / total_smoke_pixels
  average_g = cv2.sumElems(g * smoke_mask)[0] / total_smoke_pixels
  average_r = cv2.sumElems(r * smoke_mask)[0] / total_smoke_pixels

  return (int(average_b), int(average_g), int(average_r))

# ... (use smoke_mask obtained from detect_smoke function)
dominant_smoke_color = get_dominant_smoke_color(image, smoke_mask)
print("Dominant Smoke Color (BGR):", dominant_smoke_color)